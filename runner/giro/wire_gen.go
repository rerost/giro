// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package giro

import (
	"context"
	"fmt"
	"github.com/google/wire"
	"github.com/jhump/protoreflect/grpcreflect"
	"github.com/pkg/errors"
	"github.com/rerost/giro/domain/grpcreflectiface"
	"github.com/rerost/giro/domain/host"
	"github.com/rerost/giro/domain/message"
	"github.com/rerost/giro/domain/messagename"
	"github.com/rerost/giro/domain/service"
	"github.com/rerost/giro/pb"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection/grpc_reflection_v1alpha"
	"io/ioutil"
	"os"
	"strings"
)

// Injectors from wire.go:

func NewCmdRoot(ctx context.Context, cfg Config, version Version, revision Revision) (*cobra.Command, error) {
	reflectionAddr := ProvideReflectionAddr(cfg)
	clientConn, err := NewServerReflectionConn(ctx, reflectionAddr)
	if err != nil {
		return nil, err
	}
	client, err := NewServerReflectionClient(ctx, clientConn)
	if err != nil {
		return nil, err
	}
	grpcreflectifaceClient := grpcreflectiface.NewClient(client)
	rpcAddr := ProvideRPCAddr(cfg)
	hostResolver, err := ProviderHostResolver(clientConn, rpcAddr)
	if err != nil {
		return nil, err
	}
	messageNameResolver := messagename.NewMessageNameResolver(grpcreflectifaceClient)
	messageService := message.NewMessageService(grpcreflectifaceClient)
	serviceService := service.NewServiceService(grpcreflectifaceClient, hostResolver, messageNameResolver, messageService)
	lsCmd := ProviderLsCmd(serviceService)
	emptyJSONCmd := ProviderEmptyJSONCmd(messageService)
	toJSONCmd := ProviderToJSONCmd(messageService)
	toBinaryCmd := ProviderToBinaryCmd(messageService)
	metadata, err := ProviderMetadata(cfg)
	if err != nil {
		return nil, err
	}
	callCmd := ProviderCallCmd(serviceService, metadata)
	versionCmd, err := ProviderVersionCmd(version, revision)
	if err != nil {
		return nil, err
	}
	hostCmd, err := ProviderHostCmd(hostResolver)
	if err != nil {
		return nil, err
	}
	command, err := ProviderCmdRoot(lsCmd, emptyJSONCmd, toJSONCmd, toBinaryCmd, callCmd, versionCmd, hostCmd)
	if err != nil {
		return nil, err
	}
	return command, nil
}

// wire.go:

type ReflectionAddr string

type RPCAddr string

type Metadata map[string]string

func NewServerReflectionConn(ctx context.Context, reflectionAddr ReflectionAddr) (*grpc.ClientConn, error) {
	conn, err := grpc.DialContext(ctx, string(reflectionAddr), grpc.WithInsecure())
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return conn, nil
}

func NewServerReflectionClient(ctx context.Context, conn *grpc.ClientConn) (*grpcreflect.Client, error) {
	client := grpcreflect.NewClient(ctx, grpc_reflection_v1alpha.NewServerReflectionClient(conn))

	return client, nil
}

func ProvideReflectionAddr(cfg Config) ReflectionAddr {
	return ReflectionAddr(cfg.ReflectionServer)
}

func ProvideRPCAddr(cfg Config) RPCAddr {
	return RPCAddr(cfg.RpcServer)
}

func ProviderMetadata(cfg Config) (Metadata, error) {
	parsedMeataData, err := ParseMetadata(cfg.Metadata)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	for k, v := range parsedMeataData {
		zap.L().Debug("received metadata", zap.String(k, v))
	}

	return parsedMeataData, nil
}

func ProviderHostResolver(conn *grpc.ClientConn, rpcAddr RPCAddr) (host.HostResolver, error) {
	if rpcAddr != "" {
		return host.NewConstHostResolver(string(rpcAddr)), nil
	}

	client := hosts_pb.NewHostServiceClient(conn)

	return host.NewHostResolver(client), nil
}

var base = wire.NewSet(service.NewServiceService, message.NewMessageService, messagename.NewMessageNameResolver, NewServerReflectionClient,
	ProviderHostResolver,
	ProvideReflectionAddr,
	ProvideRPCAddr, grpcreflectiface.NewClient, NewServerReflectionConn,
	ProviderMetadata,
)

type LsCmd *cobra.Command

func ProviderLsCmd(serviceService service.ServiceService) LsCmd {
	cmd := &cobra.Command{
		Use:  "ls",
		Args: cobra.MaximumNArgs(1),
		RunE: func(ccmd *cobra.Command, arg []string) error {
			ctx := ccmd.Context()

			var args []string
			if len(arg) == 1 {
				args = strings.Split(arg[0], "/")
			}

			switch len(args) {
			case 0:
				srvs, err := serviceService.Ls(ctx, nil, nil)
				if err != nil {
					return errors.WithStack(err)
				}
				for _, s := range srvs {
					fmt.Println(s.Name)
				}
			case 1:
				srvs, err := serviceService.Ls(ctx, &args[0], nil)
				if err != nil {
					return errors.WithStack(err)
				}
				for _, mn := range srvs[0].MethodNames {
					fmt.Println(mn)
				}
			case 2:
				srvs, err := serviceService.Ls(ctx, &args[0], &args[1])
				if err != nil {
					return errors.WithStack(err)
				}
				for _, mn := range srvs[0].MethodNames {
					fmt.Println(mn)
				}
			}

			return nil
		},
	}
	return cmd
}

type EmptyJSONCmd *cobra.Command

func ProviderEmptyJSONCmd(messageeService message.MessageService) EmptyJSONCmd {
	cmd := &cobra.Command{
		Use:  "empty_json",
		Args: cobra.ExactArgs(1),
		RunE: func(ccmd *cobra.Command, args []string) error {
			ctx := ccmd.Context()

			json, err := messageeService.EmptyJSON(ctx, messagename.MessageName(args[0]))
			if err != nil {
				return errors.WithStack(err)
			}
			fmt.Println(string(json))

			return nil
		},
	}

	return cmd
}

type ToJSONCmd *cobra.Command

func ProviderToJSONCmd(messageeService message.MessageService) ToJSONCmd {
	cmd := &cobra.Command{
		Use:  "tojson",
		Args: cobra.RangeArgs(1, 2),
		RunE: func(ccmd *cobra.Command, args []string) error {
			ctx := ccmd.Context()

			var body string
			if len(args) == 2 {
				body = args[1]
			} else {
				b, err := ioutil.ReadAll(os.Stdin)
				if err != nil {
					return errors.WithStack(err)
				}
				body = string(b)
			}
			json, err := messageeService.ToJSON(ctx, messagename.MessageName(args[0]), message.Binary(body))
			if err != nil {
				return errors.WithStack(err)
			}
			fmt.Println(string(json))

			return nil
		},
	}
	return cmd
}

type ToBinaryCmd *cobra.Command

func ProviderToBinaryCmd(messageeService message.MessageService) ToBinaryCmd {
	cmd := &cobra.Command{
		Use:  "tobinary",
		Args: cobra.RangeArgs(1, 2),
		RunE: func(ccmd *cobra.Command, args []string) error {
			ctx := ccmd.Context()

			var body string
			if len(args) == 2 {
				body = args[1]
			} else {
				b, err := ioutil.ReadAll(os.Stdin)
				if err != nil {
					return errors.WithStack(err)
				}
				body = string(b)
			}
			bin, err := messageeService.ToBinary(ctx, messagename.MessageName(args[0]), message.JSON(body))
			if err != nil {
				return errors.WithStack(err)
			}
			fmt.Println(string(bin))

			return nil
		},
	}

	return cmd
}

type CallCmd *cobra.Command

func ParseMetadata(m string) (map[string]string, error) {
	if m == "" {
		return nil, nil
	}
	ms := strings.Split(m, ":")
	if len(ms)%2 != 0 {
		return nil, errors.New("Expect key1:val1:key2:val2 format")
	}
	md := make(map[string]string, len(ms)/2)

	for i := 0; i < len(ms); i += 2 {
		md[ms[i]] = ms[i+1]
	}
	return md, nil
}

func ProviderCallCmd(serviceService service.ServiceService, metadata Metadata) CallCmd {
	cmd := &cobra.Command{
		Use:  "call",
		Args: cobra.RangeArgs(1, 2),
		RunE: func(ccmd *cobra.Command, args []string) error {
			ctx := ccmd.Context()

			var body string
			if len(args) == 2 {
				body = args[1]
			} else {
				b, err := ioutil.ReadAll(os.Stdin)
				if err != nil {
					return errors.WithStack(err)
				}
				body = string(b)
			}

			tmp := strings.Split(args[0], "/")
			svcName := tmp[0]
			methodName := tmp[1]
			bin, err := serviceService.Call(ctx, svcName, methodName, map[string]string(metadata), message.JSON(body))
			if err != nil {
				return errors.WithStack(err)
			}
			fmt.Println(string(bin))
			return nil
		},
	}

	return cmd
}

type VersionCmd *cobra.Command

type Version string

type Revision string

func ProviderVersionCmd(version Version, revision Revision) (VersionCmd, error) {
	cmd := &cobra.Command{
		Use: "version",
		RunE: func(ccmd *cobra.Command, args []string) error {
			fmt.Printf("Version=%s, Revision=%s\n", version, revision)
			return nil
		},
	}

	return cmd, nil
}

type HostCmd *cobra.Command

func ProviderHostCmd(hostResolver host.HostResolver) (HostCmd, error) {
	cmd := &cobra.Command{
		Use:  "host",
		Args: cobra.ExactArgs(1),
		RunE: func(ccmd *cobra.Command, args []string) error {
			ctx := ccmd.Context()
			host2, err := hostResolver.Resolve(ctx, args[0])
			if err != nil {
				return errors.WithStack(err)
			}
			fmt.Println(host2)
			return nil
		},
	}

	return cmd, nil
}

func ProviderCmdRoot(lsCmd LsCmd, emptyJSONCmd EmptyJSONCmd, toJSONCmd ToJSONCmd, toBinaryCmd ToBinaryCmd, callCmd CallCmd, versionCmd VersionCmd, hostCmd HostCmd) (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "giro",
		Short: "",
	}

	cmd.AddCommand(
		lsCmd,
		emptyJSONCmd,
		toJSONCmd,
		toBinaryCmd,
		callCmd,
		versionCmd,
		hostCmd,
	)

	return cmd, nil
}
